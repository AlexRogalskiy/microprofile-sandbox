//
// Copyright (c) 2019 Contributors to the Eclipse Foundation
//
// See the NOTICE file(s) distributed with this work for additional
// information regarding copyright ownership.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

[[about]]
== About GraphQL

GraphQL is an open-source data query and manipulation language for APIs, and a runtime for fulfilling queries with existing data. GraphQL interprets strings from the client, and returns data in an understandable, predictable, pre-defined manner.
It provides an alternative, though not necessarily a replacement for REST.

GraphQL was developed internally by Facebook in 2012 before being publicly released in 2015. Facebook delivered both a https://facebook.github.io/graphql/[specification] and a https://github.com/graphql/graphql-js[reference implementation] in JavaScript.

On 7 November 2018, the GraphQL project was moved from Facebook to the newly-established https://www.linuxfoundation.org/press-release/2018/11/intent_to_form_graphql/[GraphQL foundation], hosted by the non-profit Linux Foundation. 
This is a significant milestone in terms of industry and community adoption.  
GraphQL is used by many large and small customers including Atlassian, Coursera, Facebook, GitHub, PayPal, Twitter, and https://graphql.org/users/[many more].

* More info: https://en.wikipedia.org/wiki/GraphQL
* Home page: https://graphql.org/
* Specification: https://facebook.github.io/graphql/draft/

Also see <<appendix_b>>

[[why_graphql]]
=== Why GraphQL
The main reasons for using GraphQL are:

* Improved data consumption on the client-side (IoS, Android, Web). Allowing for example to retrieve several types of data in a single request or limiting the response data to exactly the specific data requested,
* Better analysis of the exhaustiveness of data calls (allowing to know the use of each node) and better manage the deletion of deprecated fields,
* Advanced developer experience:
** The schema defines how the data can be accessed and serves as the contract between the client and the server. Developer teams on both sides can work without further communication,
** Native schema introspection enabling to discover APIs and to refine the queries on the client-side. This advantage is increased with graphical tools such as https://github.com/graphql/graphiql[GraphiQL] and https://apis.guru/graphql-voyager/[GraphQL Voyager] enabling smooth and easy APIs discovery,
** On the client-side, the query language provides a lot of flexibility and efficiency enabling developers to adapt to the constraints of their technical environments (IoS, Android, Web) while reducing server round-trips.

[[graphql_and_rest]]
=== GraphQL and REST
Before going further, it is important to clearly differenciate GraphQL from REST.

REST stands for "REpresentational State Transfer". It is an architecture style for network-based sofwtare specified by Roy Fielding in 2000 in a https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf[dissertation] defining 6 theoretical constrainsts:

. uniform interface
. stateless
. client-server
. cacheable
. layered system
. code on demand (optional).

Many people believe that REST is just doing JSON over HTTP, but REST is fundamentally technically agnostic, it is an architecure style. For instance, it doesn't require to use HTTP. However, it recommends using the maximum capacity of the underlying network protocol to apply the 6 basic principles.This is why its use on HTTP leads to optimize the HTTP semantic with a proper use of verbs (POST, GET, PUT, PATCH, DELETE) and response codes (2xx, 4xx, 5xx).

In practise REST over HTTP has become mainstream to develop modern APIs, with more or less success because the theoretical principles are not always understood by developers. In particular, the implementation of HATEOS (Hypermedia as the engine of application state), which supports the principle of uniformity, is rarely applied. This leads to inconsistent and unclear APIs.

GraphQL takes its roots from a Facebook https://facebook.github.io/graphql/[specification] published in 2015. As of this date, GraphQL has been subject to 5 releases:

* June 2018
* October 2016
* April 2016
* October 2015
* July 2015

According to its own definition: "GraphQL is a query language for describing the capabilities and requirements of data models for client‐server applications." 

It should be stressed that GraphQL is independant from any transport protocol and database technology:

* it does not recommend the use of HTTP. However, in practice, and as with REST, it is clearly the most widely used protocol,
* it isn't tied to any specific database or storage engine and is instead backed by existing code and data.

[[what_make_graphql_different]]
=== What make GraphQL different?
In practice, here are the main differentiating features of GraphQL compared to REST:

* *schema-driven*: a GraphQL API natively exposes a schema describing the structure of the data and operations (queries and mutations) exposed. This schema acts as a contract between the server and its clients. In a way GraphQL provides an explicit answer to the API discovery problem where REST relies on the ability of developers to use HATEOS,
* *single HTTP endpoint*: a typical GraphQL API is made of a single endpoint and access to data and operations is achieved through the query language. In a HTTP context, the endpoint is defined as a URL and the query can be  transported as a query string (GET request) or in the request body (POST request),
* *flexible data retrieval*: by construction the query language enables to select the expected data in the response with a fine level of granularity,
* *reduction of server requests*: the language allows the client to aggregate the expected data into a single request,
* *easier version management*: thanks to the native capabilities to create new data while deprecating old ones, 
* *partial results*: partial results are delivered by the GraphQL server in case of errors. A GraphQL result is made of data and errors. It's not an all or nothing approach. How to process such a result is the responsability of the client,
* *low coupling with HTTP*: GraphQL does not try to make the most of the HTTP semantic. Queries can be made using GET or POST requests. The HTTP result code  does not reflect the GraphQL response. This aspect is subject to discussion and perhaps GraphQL will have to evolve towards a better integration with HTTP to broaden its adoption,
* *challenging authorization handling*: an appropriate data access authorization policy must be defined and implemented to counter the extreme flexibility of the query language. For example, a customer may request data that are authorized and others that are prohibited,
* *challenging API management*: most API management solutions are based on REST capabilities and allow for URL-based policies to be established. As we have seen, a GraphQL API has a single entry point. An analysis of the request is necessary to establish a policy. For instance, to prevent the execution of an overly complex request that would crash the server.

[[graphql_beyond-the-hype]]
=== GraphQL beyond the hype

A lot has been said about GraphQL since its inception, creating noise and opposing believers vs skepticals. 

We don't want to fuel the GraphQL vs REST controversy. We do not believe that GraphQL is a silver bullet and that it will replace REST. We do think that it is quite valid in some use cases and that it has a role to play in the world of modern APIs. 

This opinion seems to us to be confirmed by:

* the growth and dynamism of the  community, with, for example, events of international scope such as https://www.graphqlconf.org/[GraphQL Conf],
* the adoption of the technology by major IT players (although it is difficult to have precise figures),
* the recent creation of the https://gql.foundation/[GraphQL foundation] allowing for outreach beyond Facebook.

[[graphql_and_database]]
=== GraphQL and Databases

GraphQL is about data manipulation and can be compared to SQL but this is a misconception. 

GraphQL is not a database technology. It is a query language for APIs, not databases. It is database and storage agnostic and can be used in front of any kind of backend, with or without database.

One of GraphQL's strength is its multi-datasource capability enabling to aggregate data from various sources with a single API.


[[graphql_licensing]]
=== GraphQL licensing
This arcticle https://nordicapis.com/what-the-graphql-patent-release-means-for-the-api-industry/[What the GraphQL patent Release Means For the API industry] written in December 2017 details the licensing issue.

GraphQL was initially released with a license that could lead to potential future conflicts with software licensed under Apache.In September of 2017, GitLab officially froze their GraphQL project due to these concerns.

On September 26th, 2017, Facebook relicensed GraphQL under an http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0[OWFa 1.0 license], granting a perpetual license to users of GraphQL.

There’s still some cause for concern around the new licensing scheme, however. Facebook has broadly adopted the MIT license, which doesn’t expressly include a patent grant. By choosing this approach, Facebook does not convey with the MIT license any patent grants as they would have under the Apache.

According to the article, most of the concerns are simply conjecture. But if the possibility of future concern is significant enough to worry an organization, they should consider moving away from GraphQL.

What is not clear is the scope of that concern; is it about the specification or the JavaScript Reference Implementation ?

Would it be possible for the Eclipse Foundation to clarify the legal risk?




[[why_microprofile]]
=== Why MicroProfile

The official purpose of MicroProfile is to optimize Enterprise Java for a microservices architecture and delivers application portability across multiple MicroProfile runtimes.

GraphQL is already widely used in Microservices architectures as the API Endpoint. 
As noted in the following section (<<known_java_libraries>>), there are several Java-based GraphQL libraries available, but none with the reach of the MicroProfile community. 
GraphQL continues to grow in popularity, and as such there should be a specification for GraphQL development in Java. 
MicroProfile is the optimal place to host that standard as it is open, ideally suited for incubating technologies, and has broad reach both in terms of the user community and vendor support.

[[what_graphql_is_not]]
=== What MicroProfile GraphQL is not

This specification will focus on making it easy for developers to create a GraphQL Service/Endpoint and publish it as an API. 
Where the data comes from (NoSQL, Relational DB, another service, etc.) is not the concern of this Proposed Specification. 